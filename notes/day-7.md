

## [Day 7 - Part 1] Storage Classes, Unions & Advanced Types

ุจูุงุกู ุนูู ุทูุจูุ ูููุตุต **Day 7 (ุงูุฌุฒุก ุงูุฃูู)** ุจุงูุชูุตูู ุงููููุ ูุฏู ุณูุดู ุชููู ุฌุฏุงู ูุฃูู ุจูุชุนุงูู ูุน ุงูู Storage Classes ูุงูู User Defined Types ุงููู ุจุชูุฑู ุงููุจุฑูุฌ ุงูุนุงุฏู ุนู ุงูู Embedded Software Engineer.

---

## 1. ๐๏ธ Scopes & The extern Keyword

ูุจู ูุง ูุฏุฎู ูู ุงูุนููุ ูุงุฒู ููุฑู ุจูู "ููู ุดุงูู ููู".

- **Block Scope:** ุฃู ุญุงุฌุฉ ุฌูู `{ }` (ุณูุงุก ูุงููุดูุ ifุ for) ุจุชููุช ุจูุฌุฑุฏ ุงูููุณ ูุง ูุชููู.
    
- **Global Variable:** "ููุทุด ูููู". ุจูุชุดุงู ูู ุงููุงูู ููู.
    

### The Multi-File Dilemma

ูู ูุณูุช ุงูููุฏ ูู `main.c` ู `print.c`:

- **ุงููุดููุฉ:** ูู ุนุฑูุช `int x = 10` ูู `main.c` ูุญุงููุช ุชุณุชุฎุฏูู ูู `print.c`ุ ุงููููุจุงููุฑ ููุถุฑุจ (Undefined Reference). ูููุ ูุฃู ุงูู Global Scope ุงูุชุฑุงุถูุงู ูู **File Scope**.
    
- **ุงูุญู (extern):** ูุงุฒู ุชุฑูุญ ูู `print.c` ูุชูููู "ูุง ุนู ุงููููุจุงููุฑุ ููู ูุชุบูุฑ ุงุณูู `x` ููุนู `int` ููุฌูุฏ ูู ููุงู ูุงุ ูุชุนููุด ูุงุญุฏ ุฌุฏูุฏุ ุฏูุฑ ุนููู".
    
    - `extern int x;` -> **Declaration Only** (ูุชุญุฌุฒูุด ููุงู ูู ุงูููููุฑูุ ุฏู ูุฌุฑุฏ ุฅุฎุทุงุฑ).
        

> [!danger] ุชุญุฐูุฑ
> 
> ููููุน ุชุนูู Initialization ูุน ุงูู extern (extern int x = 5 -> ูุตูุจุฉ/Compiler Error).

Code snippet

```mermaid
graph TD
    subgraph "main.c"
    A["int x = 10; <br/> Definition & Initialization"]
    end

    subgraph "print.c"
    B["extern int x; <br/> Declaration only"]
    C["printf(x); <br/> Linker finds x in main.c"]
    end

    B -.->|Links to| A
```

---

## 2. ๐ฆ The static Keyword (The Chameleon)

ูููุฉ `static` ูู ูุบุฉ C ูููุง 3 ูุนุงูู ูุฎุชููุฉ ุชูุงูุงู ุญุณุจ ููุงููุง. ุฏู "ุงูุญุฑุจุงุก" ุจุชุงุนุฉ ุงููุบุฉ.

### A. Static Global / Static Function (Private Access)

- **ุงูููุงู:** ูุจู Global Variable ุฃู Function.
    
- **ุงูุชุฃุซูุฑ:** ุจูุฎูู ุงููุชุบูุฑ/ุงููุงููุดู **Private** ูููุงูู ุฏู ุจุณ.
    
- **ุงููุฏู:** ุงูู Encapsulation. ุนุดุงู ูุญุฏุด ูู ุจุฑู ูุนูู `extern` ููุดูู ุงููุชุบูุฑ ุจุชุงุนู ููุจูุธู. ูู ุญุงููุช ุชุนูู extern ููุชุบูุฑ staticุ ุงูููููุฑ ูููููู "ูุด ุดุงููู".
    

### B. Static Local (The Immortal Local)

- **ุงูููุงู:** ุฌูู ุงููุงููุดู (`static int count = 0;`).
    
- **ุงูุชุฃุซูุฑ:**
    
    - **Lifetime:** ุจููุถู ุนุงูุด ุทูู ูุฏุฉ ุงูุจุฑูุงูุฌ (ุจูุชููู ูู ุงูู **Stack** ููู **Data Segment**).
        
    - **Scope:** ูุณู Local (ูุญุฏุด ููุฏุฑ ููุตูู ุบูุฑ ุงููุงููุดู ุฏู).
        
- **Initialization:** ุจูุญุตู ูุฑุฉ ูุงุญุฏุฉ ููุท ุนูุฏ ุฃูู ุงุณุชุฏุนุงุก. ูู ุงููุฑุงุช ุงูุฌุงูุฉุ ุจููุชูุฑ ูููุชู ุงููุฏููุฉ.
    

**Code Reconstruction: Static Local Logic**

C

```c
void counter() {
    static int cnt = 0; // Initialized ONCE
    cnt++;
    printf("%d ", cnt);
}

int main() {
    counter(); // Output: 1
    counter(); // Output: 2 (Remembers old value)
    counter(); // Output: 3
    // printf("%d", cnt); // ERROR: Scope is still local
}
```

---

## 3. ๐ก๏ธ Header Guards (#ifndef)

ููุง ุงููุดุฑูุน ููุจุฑุ ูููู ุชุนูู `#include "file.h"` ูุฑุชูู ุจุงูุบูุท (ูุฑุฉ ูู main ููุฑุฉ ุฌูู file2.h). ุฏู ุจูุนูู **Redefinition Error**.

**ุงูุญู:** ุงูู Header Guards. ุจุงุชุฑู ุซุงุจุช ูุงุฒู ุชุญูุธู.

C

```c
#ifndef PRINT_H_  // ูู ุงููููุฉ ุฏู ูุด ูุชุนุฑูุฉ
#define PRINT_H_  // ุนุฑููุงุ ูููุฐ ุงููู ุชุญุช

void printFunction();
struct Data { int x; };

#endif // ููุงูุฉ ุงูุดุฑุท
```

- **ุฃูู ูุฑุฉ:** `PRINT_H_` ูุด ูุชุนุฑูุฉ -> ูุฏุฎู ูุนุฑููุง ูููุณุฎ ุงูููุฏ.
    
- **ุชุงูู ูุฑุฉ:** `PRINT_H_` ูุชุนุฑูุฉ -> ุงูู Preprocessor ูุดูู ุงูููุฏ ููู ููุณูุจ ููุงูู ูุฑุงุบ.
    

---

## 4. โก Advanced Storage Classes (register & volatile)

### A. register (Speed Request)

ุจุชุทูุจ ูู ุงููููุจุงููุฑ ูุญุท ุงููุชุบูุฑ ุฏู ูู **CPU Register** ุจุฏู ุงูู **RAM**.

- **ุงูุงุณุชุฎุฏุงู:** ูู ุนูุฏู ุนุฏุงุฏ Loop ุจููู ููููู ูุฑุฉ ูุนุงูุฒ ุณุฑุนุฉ ุฑููุจุฉ.
    
- **ุชุญุฐูุฑ:** ุฏู ูุฌุฑุฏ "ุทูุจ". ูู ูููุด ููุงู ูู ุงูุฑูุฌุณุชุฑุงุชุ ุงููููุจุงููุฑ ููุทูุดู ููุฑููู ูู ุงูุฑุงู.
    

### B. volatile (The Anti-Optimization)

ุฏู ุฃูู Keyword ููู Embedded Systems.

- **ุงููุดููุฉ:** ุงููููุจุงููุฑ ุจูุนูู Optimization. ูู ููู ููุฏ ุฒู:
    
    C
    
    ```c
    int x = 0;
    while(x == 0); // Infinite Loop?
    ```
    
    ุงููููุจุงููุฑ ููููู: "ูุญุฏุด ุจูุบูุฑ x ุฌูู ุงูููุจุ ูุจูู ุงูููุจ ุฏู ูุง ููุงุฆูุฉุ ุฃูุง ูุด ูุฑูุญ ุฃูุฑุฃ x ูู ุงูููููุฑู ูู ุดููุฉุ ุฃูุง ูุนุชุจุฑูุง ุจู 0 ูุฃุฎูุต".
    
- **ุงูุณููุงุฑูู:** ูู ุงูู Embeddedุ ุงููุชุบูุฑ `x` ูููู ูุชุบูุฑ ูู ุจุฑู (ุนู ุทุฑูู **ISR** ุฃู ูุงุฑุฏููุฑ).
    
- **ุงูุญู:** `volatile int x;` -> ุจุชููู ูููููุจุงููุฑ: "ูุง ูุญูุฏ ูููุฏู (ุนูู ุฑุฃู ูููุง)ุ ูููุด ุฏุนูุฉ! ุงููุชุบูุฑ ุฏู ูููู ูุชุบูุฑ ูู ูุฑุง ุธูุฑูุ ุฑูุญ ูุงุชู ูู ุงูููููุฑู ูู ูุฑุฉ ุบุตุจ ุนูู".
    

---


## 5. ๐ typedef vs #define (The Type Safety Trap)

ุนุดุงู ููุชุจ ููุฏ Portable (ูุดุชุบู ุนูู ุฃู ูููุฑู)ุ ุจูุนุฑู ุฃููุงุน ุฒู `uint8` ู `uint32`. ูุณุชุฎุฏู ูููุ

- `#define`: ูุฌุฑุฏ Text Replacement (ุจุญุซ ูุงุณุชุจุฏุงู). ุบุจู ุฌุฏุงู.
    
- `typedef`: ุจุชุนูู ุงุณู ุฌุฏูุฏ ูููุน ุฏุงุชุง ุญูููู. ุฃุฐูู ูุขูู.
    

> [!danger] The Pointer Trap (ุณุคุงู ุงูุชุญุงูุงุช)
> 
> ูู ุนุงูุฒ ุชุนุฑู 2 ุจูููุชุฑุฒ ูู ุณุทุฑ ูุงุญุฏ:
> 
> C
> 
> ```
> #define PTR_D char* // Stupid replacement
> typedef char* PTR_T;  // Smart type definition
> ```

> // Case 1: Using #define (The Trap)
> 
> PTR_D p1, p2;
> 
> // Preprocessor expands it to: char* p1, p2;
> 
> // Result: p1 is Pointer (char*), but p2 is just a CHAR! (Catastrophe)

> // Case 2: Using typedef (The Safe Way)
> 
> PTR_T p3, p4;
> 
> // Compiler treats PTR_T as a full data type.
> 
> // Result: p3 is Pointer, and p4 is Pointer. (Correct)

---

## 6. ๐ฆ [[Unions]] (Shared Memory Magic)

ุงูู Union ูู "ุนูุจุฉ" ุจุชุดูู ุฏุงุชุง ุฃููุงุนูุง ูุฎุชููุฉุ ุจุณ ูู ููุณ ุงูููุงู ูู ุงูููููุฑู.

- **ุงูุญุฌู:** ุญุฌู ุงูู Union = ุญุฌู ุฃูุจุฑ ุนูุตุฑ ุฌูุงู (ูุด ุงููุฌููุน ุฒู ุงูู Struct).
    
- **ุงูุงุณุชุฎุฏุงู:** ุชูููุฑ ุงูููููุฑูุ ุฃู ุงูุชุนุงูู ูุน ุงูุฏุงุชุง ุจุฃุดูุงู ูุฎุชููุฉ (Type Punning).
    

### Hack: Endianness Check using Union

ุจุฏู ูุง ุชุณุชุฎุฏู Pointers ุนุดุงู ุชุนุฑู ุฅูุช Little Endian ููุง Big Endianุ ุงุณุชุฎุฏู Union.

C

```c
typedef union {
    uint32_t val;    // 4 Bytes (e.g., 0x00000001)
    uint8_t bytes[4]; // Array mapping the same 4 bytes
} EndianCheck;

EndianCheck u;
u.val = 1;

// If Little Endian: Memory is [01 00 00 00]
// u.bytes[0] will be 1.
if (u.bytes[0] == 1) printf("Little Endian");
```

---

## 7. ๐ค [[Bit Fields]] (Memory Squeezing)

ูู ุนุงูุฒ ุชููุฑ ูู ุงูููููุฑู ูุฃูุตู ุฏุฑุฌุฉุ ูุนุงูุฒ ูุชุบูุฑ ูุดูู 3 ุจุช ุจุณ (ููู ูู 0 ูู 7).

- **Syntax:** ุฌูู ุงูู Struct.
    
    C
    
    ```c
    struct Flags {
        uint8_t enable : 1; // Takes 1 bit
        uint8_t mode   : 3; // Takes 3 bits
        // Total is still padded to closest Byte/Word alignment
    };
    ```
    
- **ุงููุงุฆุฏุฉ:** ุงูุชุนุงูู ูุน ุงูู Hardware Registers ุงููู ุจุชุจูู ูุชูุณูุฉ ุจุชุงุช.
    
- **ุงูุนูุจ:** ููุฏุฑุด ุฃุนูู `&variable` (Address Of) ูู Bit Fieldุ ูุฃู ุฃูู ุนููุงู ูู ุงูููููุฑู ูู Byte ูุงูู.
    

---

## 8. ๐ข [[Enum]] (Killing Magic Numbers)

ุจุฏู ูุง ููุชุจ 0 ู 1 ู 2 ูููุณู ุฏูู ุจุชูุน ุฅููุ ุจูุณุชุฎุฏู `enum`.

- **ุงูููุฒุฉ:** ุจุชุฏู ุฃุณูุงุก ููุฃุฑูุงู (`GPIO_INPUT`, `GPIO_OUTPUT`).
    
- **Auto-Increment:** ูู ุจุฏุฃุช ุจู `JAN=1`ุ ุงููู ุจุนุฏู FEB ุจูุจูู 2 ุฃูุชููุงุชูู.
    
- **Type Safety:** ูู Cุ ุงูู Enum ูู `int` ูู ุงูุขุฎุฑุ ููููู ูุงุฎุฏ ุฃู ุฑูู (ุญุชู ูู ูุด ูู ุงูููุณุชุฉ). ูููู ุจูุฎูู ุงูููุฏ ููุฑูุก (Readable).
    

The Config Function Pattern

ุจุฏู ูุง ุชุจุนุช 0 ุฃู 1 ูููุงููุดูุ ุงุจุนุช ุงูู Enum.

C

```c
typedef enum { INPUT, OUTPUT } Direction;
void setPinDir(int pin, Direction dir) { ... }

// Call becomes readable:
setPinDir(5, OUTPUT); // Better than setPinDir(5, 1);
```

---

## 9. ๐ Inline Functions vs Macros

ุนุงูุฒ ุณุฑุนุฉ ุงูู Macros ุจุณ ุฃูุงู ุงููุงููุดูุ

- **Macro Function:** `#define SUM(x,y) (x+y)`. 
- ุณุฑูุนุฉ (Text replacement) ุจุณ ูููุงุด Type Checking ููููู ุชุณุจุจ ุจูุงูู ูู ุงูุฃููููุงุช.
    
- **Inline Function:** `inline int sum(int x, int y)`.
    
    - ุจุชููู ูููููุจุงููุฑ: "ูู ุณูุญุชุ ุฎุฏ ููุฏ ุงููุงููุดู ุฏู ูุญุทู ููุงู ุงูุงุณุชุฏุนุงุก (Copy-Paste) ุนุดุงู ูููุฑ ุงูู **Context Switching Overhead**".
        
    - ูู ููุณ ุงูููุชุ ูู ูุงููุดู ุญููููุฉ ุจู Type Checking.
        

---

## [Day 7 - Part 2] Double Pointers, 2D Arrays & The Arithmetic Trap

ุงูุฌุฒุก ุฏู ูู "ุงูุจุนุจุน" ุงูุญูููู ููุจูููุชุฑุฒ. ุงููููุฏุณ ูููุง ูุงู: "ูู ุฏูุงุบู ูููุช ููุงุ ุฃูุง ูุนุชุฒู ุงูุชุฏุฑูุณ". ุฑูุฒ ุฌุฏุงู ูุฃู ุฏู ุงููู ุจููุฑู ุจูู ุงูู Senior ูุงูู Junior.

---

## 1. ๐ [[Pointer to Pointer]] (The Double Dereference)

- **ุงูุชุนุฑูู:** ูู ูุชุบูุฑ ุจูุดูู ุนููุงู ูุชุบูุฑ ุชุงููุ ูุงููุชุบูุฑ ุงูุชุงูู ุฏู ูู ููุงู ุจูููุชุฑ ุจูุดุงูุฑ ุนูู ูููุฉ.
    
- **Syntax:** `int** ptr;`
    
- **The Visualization:**
    
    1. `x` (ูููุฉ 5).
        
    2. `ptr1` (ุดุงูู ุนููุงู `x`).
        
    3. `ptr2` (ุดุงูู ุนููุงู `ptr1`).
        
- **Access:**
    
    - `*ptr2` -> ูุฌูุจ `ptr1` (ุนููุงู `x`).
        
    - `**ptr2` -> ูุฌูุจ `x` (ุงููููุฉ 5).
        

> [!quote] Mina's Metaphor
> 
> "ุนุดุงู ุชุฌูุจ ุงููููุฉุ ูุงุฒู ุชุบุฒู ูุฑุชูู (Two Pokes/Dereferences). ูู ูุฌูุฉ ุจุชุฏุฎู ูููู ุฃุนูู".

Code snippet

```mermaid
graph LR
    A["ptr2 (0x300)"] -->|Points to| B["ptr1 (0x200)"]
    B -->|Points to| C["Variable x (Value: 5)"]

    style A fill:#f9f,stroke:#333
    style B fill:#bbf,stroke:#333
    style C fill:#bfb,stroke:#333
```

---

## 2. ๐ชค Pointer Arithmetic Traps (ุณุคุงู ุงูุงูุชุฑููู ุงููุงุชู)

ุงูุชุฑุชูุจ (Precedence) ุจูู `++` ู `*` ุจูุนูู ููุงุฑุซ. ุฑูุฒ ูู ุงููุฑู ุจูู ุงูุญุงูุงุช ุฏู:

### Case A: `*ptr++` (The Deceiver)

- **ุงูุฃููููุฉ:** ุงูู Post-increment (`++`) ุฃุนูู ูู Dereference (`*`)ุ ุจุณ ุงูุชูููุฐ ุจูุญุตู ุจุนุฏูู.
    
- **ุงูุณููุงุฑูู:**
    
    1. ูุงุช ูููุฉ `ptr` ุงููุฏููุฉ ูุงุณุชุฎุฏููุง ููู Dereference (`*ptr`).
        
    2. ุฒูุฏ ุนููุงู ุงูู `ptr` ููุณู (ููุท ููููุทุฉ ุงููู ุจุนุฏูุง).
        
- **ุงููุชูุฌุฉ:** ุจุชุฌูุจ ุงููููุฉ ุงูุญุงููุฉุ ูุงูุจูููุชุฑ ุจูุชุญุฑู ุฎุทูุฉ ููุฏุงู.
    

### Case B: `(*ptr)++` (Value Change)

- **ุงูุฃููููุฉ:** ุงูุฃููุงุณ `()` ุฃุฌุจุฑุชู ูููุฐ ุงูู Dereference ุงูุฃูู.
    
- **ุงูุณููุงุฑูู:**
    
    1. ูุงุช ุงููููุฉ ุงููู ุฌูู ุงูุตูุฏูู (`*ptr`).
        
    2. ุฒูุฏ ุงููููุฉ ุฏู ุจูุงุญุฏ.
        
- **ุงููุชูุฌุฉ:** ุงูุจูููุชุฑ ุซุงุจุช ูู ููุงููุ ูุงููููุฉ ุงููู ูู ุงูููููุฑู ุฒุงุฏุช.
    

### Case C: `++*ptr`

- **ุงูุฃููููุฉ:** `++` (Prefix) ู `*` ูููู ููุณ ุงูุฃููููุฉ (Right-to-Left).
    
- **ุงูุณููุงุฑูู:** ูุงุช ุงููููุฉุ ูุฒูุฏูุง ููุฑุงู. (ุฒู Case B ุจุณ Prefix).
    

**Code Reconstruction: The Quiz**

C

```c
int arr[] = {10, 20, 30};
int* p = arr;

printf("%d", *p++); // Prints 10, then p moves to &arr[1]
printf("%d", (*p)++); // Prints 20, then arr[1] becomes 21 (p stays at &arr[1])
```

---

## 3. ๐ธ๏ธ The 2D Array Nightmare (Three Ways to Access)

ุฅุฒุงู ูุนูู ุจูููุชุฑ ูุดุงูุฑ ุนูู 2D Array `arr[3][4]`ุ ุฏู ุฃุตุนุจ ุญุชุฉ ูู ุงูููุฑุณ.

### Method 1: Flattening (The "Quarter Pounder" Pointer)

- ุงุณุชุฎุฏู ุจูููุชุฑ ุนุงุฏู `int* p = (int*)arr`.
    
- ุชุนุงูู ูุนุงูุง ูุฃููุง 1D Array ุทูููุฉ.
    
- `Index = row * COLS + col`.
    

### Method 2: [[Pointer to Array]] (`int (*p)[4]`)

- **Syntax:** `int (*p)[4];` (ุงูุฃููุงุณ ูููุฉ ุฌุฏุงู).
    
- **ุงููุนูู:** "ูุง ูููุจุงููุฑุ `p` ุฏู ุจูููุชุฑุ ููุง ุฃูููู `p++`ุ ููุท ุตู ูุงูู (3 * 4 bytes = 12 bytes)".
    
- **ุงูุงุณุชุฎุฏุงู:** ุฏู ุงูููุน ุงููุญูุฏ ุงููู ูููุน ูุณุชูุจู 2D Array ูู ูุงููุดู `void func(int (*p)[4])`.
    
- **ุงูุนูุจ:** ูุงุฒู ุชุซุจุช ุนุฏุฏ ุงูุนูุงููุฏ (Fixed Columns).
    

### Method 3: [[Array of Pointers]] (`int* p[3]`)

- **Syntax:** `int* p[3];` (ูู ุบูุฑ ุฃููุงุณ ุนูู ุงููุฌูุฉ).
    
- **ุงููุนูู:** ุฏู Array ุนุงุฏูุฉุ ุจุณ ูู ุนูุตุฑ ูููุง ุนุจุงุฑุฉ ุนู ุจูููุชุฑ.
    
- **ุงูุงุณุชุฎุฏุงู:** ูุนูู **Jagged Array** (ุตููู ุจุฃุทูุงู ูุฎุชููุฉ). ูู ุจูููุชุฑ ูุดุงูุฑ ุนูู ุตู ูุณุชูู ูู ุงูููููุฑู.
    

Code snippet

```mermaid
graph TD
    subgraph "Pointer to Array (*p)[4]"
    A[ptr] -->|Jumps Row 0| R0["Row 0: 1,2,3"]
    A -.->|p++ Jumps to| R1["Row 1: 4,5,6"]
    end

    subgraph "Array of Pointers *p[3]"
    B[p0] --> R_A["Row A somewhere"]
    C[p1] --> R_B["Row B somewhere else"]
    D[p2] --> R_C["Garbage/Null"]
    end
```

---

## 4. ๐ซ Array of Strings (The Read-Only Trap)

ููุง ุชุนูู: `char* names[] = {"Mina", "Ali"};`

- **ุงูุชุญููู:** ุฏู Array of Pointers.
    
- `names[0]` ุจูุดุงูุฑ ุนูู "Mina".
    
- "Mina" ูุชุฎุฒูุฉ ูู ุงูู **[[Read-Only Data]]** (`.rodata`).
    
- **ุงูุฎุทุฑ:** ูู ุญุงููุช ุชุนูู `names[0][0] = 'N';` -> Crash (**Segmentation Fault**).
    

> [!note] Mina's Note
> 
> ุนุดุงู ุชุนุฏู ูููุงุ ูุงุฒู ุชุนูููุง 2D Array ุนุงุฏูุฉ char names[2][10] (ุชุชุญุฌุฒ ูู ุงูู Stack).

---

## 5. ๐๏ธ Intro to [[Dynamic Memory Allocation]] (The Heap)

ุฏุฎููุง ูู "ุนุฏู ุงููู ูุงูุฅูุณุงู" (ุนูู ุฑุฃู ูููุง): ุงูู **[[Heap Memory]]**.

- **ุงููุฏู:** ุญุฌุฒ ููููุฑู ููุช ุงูุชุดุบูู (Runtime) ูุด ููุช ุงููููุจุงูู (Compile time).
    
- **Functions:**
    
    - `malloc(size)`: ุจุชุญุฌุฒ ููููุฑู (ูููุง Garbage).
        
    - `calloc(n, size)`: ุจุชุญุฌุฒ ูุชุตูุฑูุง (Zero Initialization).
        
    - `realloc`: ุจุชูุจุฑ ูุณุงุญุฉ ูุญุฌูุฒุฉ ูุจู ูุฏู.
        
    - `free`: (ูููุฉ ุฌุฏุงู) ุนุดุงู ุชุฑุฌุน ุงูููููุฑู ูุชููุน ุงูู **[[Memory Leak]]**.
        
- **Return Type:** ุจุชุฑุฌุน `void*` (Generic Pointer) ูุงุฒู ุชุนููู Casting (ุฃู ุชุณูุจู ูู C).
    

---
